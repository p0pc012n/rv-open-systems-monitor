The Waveshare 2.9 in ePaper four color display for pico strips a grayscale image bytearray and passes two images to the display that are overlaid for the final image.

I could not consistently display grayscale images using the original Waveshare Pico_ePaper-2.9 driver. There is color inversion occuring and the way the driver splits the bytearray in the original driver was causing artifacts. I forked the original driver and inserted a simple function to bypass the bytearray processing of the original driver and instead pass two pre-processed bytearrays. https://github.com/p0pc012n/pico_epaper_image/blob/main/python/Pico_ePaper-2.9.py

The Waveshare Wiki for the 2.9 in ePaper grayscale display can be found here: https://www.waveshare.com/wiki/Pico-ePaper-2.9

There are some other variations of the driver i came across that all aim to simplify the Waveshare driver that could be considered as well. Passing grayscale images seem to be the most difficult function to execute properly with the original Waveshare driver, as well as understanding how the Look up tables (LUT) are used for the display.

The GUI art (.png images) was created in GIMP. The .png files were all processed using this python script: https://github.com/p0pc012n/PNG_to_epaper_converter
This PNG_to_epaper_converter is used on a PC to import a .png and the output saves two bytearrays labeled with a _x24 and _x26 marker respectively. This script accounts for the color inversion that occurs writing to the waveshare display and can be passed directly into the added function in the display driver for writing the final image on the display.

Writing grayscale images to the epaper display seem to be limited to only calling the framebuffer once. The official Waveshare driver provides an example that can be run and proves that the built-in functions to the Framebuffer module can be called multiple times before calling the final function to write the framebuffer to the display, however in my experience, any subsequent writing to the framebuffer overwrote the pre-existing data. After multiple failed attempts i focused on writing a single image (composed of one bytearray to the x24 registry and a second to the x26 registry).

I wanted the system GUI to display different images and colors based on the read voltages that determine the system status. The solution i found involved a more manual approach to pixel mapping. I wrote a crude script ("clean_byte.py") to "crop" the generated bytearrays for all the differrent status of the system monitor display. The "cropped" bytearrays for a given status are all the same size to eliminate any artifacting.

During operation, the volage valeus are read at the Pico 2 which determines the "status" of the battery, gray water tank, and fresh water tank. The determined status is then written over the subsect of bytes on the main GUI (the panel_base bytearrays).